(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{412:function(t,o,a){"use strict";a.r(o);var e=a(56),v=Object(e.a)({},(function(){var t=this,o=t.$createElement,a=t._self._c||o;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"tcp-快速打开原理-tfo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-快速打开原理-tfo"}},[t._v("#")]),t._v(" TCP 快速打开原理 （TFO）")]),t._v(" "),a("p",[t._v("TCP 的三次握手时很麻烦的，如果每次都需要进行建立三次握手。能不能优化呢？")]),t._v(" "),a("p",[t._v("这个优化手段，就是 TCP 快速打开（TFO）的原理.")]),t._v(" "),a("p",[t._v("我们可以借助 SYN Flood 攻击时提到的 SYN Cookie。")]),t._v(" "),a("h2",{attrs:{id:"tfo-流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tfo-流程"}},[t._v("#")]),t._v(" TFO 流程")]),t._v(" "),a("p",[t._v("首轮三次握手:\n首先客户端发送 SYN 给服务端，服务端接收到。")]),t._v(" "),a("p",[t._v("服务端不是直接回复 SYN + ACK , 而是通过计算一个 SYN Cookie，将这个 Cookie 放到 TCP 报文的 Fast Open 选项中，然后才返回给客户端。")]),t._v(" "),a("p",[t._v("客户端拿到这个 Cookie 的值缓存下来，后面正常完成三次握手。")]),t._v(" "),a("p",[t._v("首轮三次握手没有什么不一样的，不一样的是之后的握手.")]),t._v(" "),a("h3",{attrs:{id:"之后的三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#之后的三次握手"}},[t._v("#")]),t._v(" 之后的三次握手")]),t._v(" "),a("p",[t._v("之后的三次握手中，客户端会将之前缓存的 Cookie、SYN 和 HTTP 请求发送给服务端，服务端严重 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回 SYN + ACK。")]),t._v(" "),a("p",[t._v("现在服务端能够发 HTTP 响应了。三次握手虽然还没有建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。")]),t._v(" "),a("p",[t._v("客户端的 ACK 还是需要正常传回的，只是这个 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。")]),t._v(" "),a("h2",{attrs:{id:"tfo-优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tfo-优势"}},[t._v("#")]),t._v(" TFO 优势")]),t._v(" "),a("p",[t._v("TFO 的优势不是在于首轮的三次握手，而是在于后面的握手，在拿到 Cookie 并通过以后，可以直接返回 HTTP 响应，可以充分利用 1 个 RTT（往返时间）的时间提前进行数据传输，积累起来是一个较大的优势。")])])}),[],!1,null,null,null);o.default=v.exports}}]);