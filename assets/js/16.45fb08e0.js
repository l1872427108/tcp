(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{416:function(v,_,t){"use strict";t.r(_);var a=t(56),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"tcp拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp拥塞控制"}},[v._v("#")]),v._v(" TCP拥塞控制")]),v._v(" "),t("p",[v._v("TCP 每条连接都需要维护两个核心状态：")]),v._v(" "),t("ul",[t("li",[v._v("拥塞窗口")]),v._v(" "),t("li",[v._v("慢启动阈值")])]),v._v(" "),t("h3",{attrs:{id:"拥塞窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞窗口"}},[v._v("#")]),v._v(" 拥塞窗口")]),v._v(" "),t("p",[v._v("拥塞窗口（cwnd）是指目前自己还能传输的数据量大小。")]),v._v(" "),t("ul",[t("li",[v._v("接收窗口（rwnd）是指 接收端的限制.")]),v._v(" "),t("li",[v._v("拥塞窗口（cwnd）是发送端的限制。")])]),v._v(" "),t("p",[v._v("发送窗口 = min(rwnd, cwnd);")]),v._v(" "),t("p",[v._v("去两者的较小值，拥塞控制，就是来控制 cwnd 的变化。")]),v._v(" "),t("h3",{attrs:{id:"慢启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#慢启动"}},[v._v("#")]),v._v(" 慢启动")]),v._v(" "),t("p",[v._v("刚开始进入传输数据的阶段，并不知道现在的网路是什么情况，如果太过于激进，容易发生疯狂丢包，给网络带来灾难。")]),v._v(" "),t("p",[v._v("拥塞控制就是要采用一种算法来慢慢的适应整个网络，这种算法叫慢启动。")]),v._v(" "),t("ul",[t("li",[v._v("首先，三次握手，双方宣告自己的接收窗口大小。")]),v._v(" "),t("li",[v._v("双方初始化自己的拥塞窗口（cwnd）大小。")]),v._v(" "),t("li",[v._v("在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口就翻倍，也就是每经历一个 RTT，cwnd 就翻倍。10，20，40...")])]),v._v(" "),t("p",[v._v("但是不能够无限的增长下去，它的阈值叫做慢启动阈值。达到这个阈值，就需要进行控制了。")]),v._v(" "),t("h3",{attrs:{id:"拥塞避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免"}},[v._v("#")]),v._v(" 拥塞避免")]),v._v(" "),t("p",[v._v("之前是 cwnd 翻倍的，现在达到阈值，cwnd 就加一点: 1/cwnd.")]),v._v(" "),t("p",[v._v("慢启动和拥塞避免使一起作用的。")]),v._v(" "),t("h3",{attrs:{id:"快速重传-解决是否需要重传的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速重传-解决是否需要重传的问题"}},[v._v("#")]),v._v(" 快速重传 (解决是否需要重传的问题)")]),v._v(" "),t("p",[v._v("在 TCP 传输的过程中，如果发生了丢包，接收端发送数据不能按照顺序到达，接收端的处理是重复发送之前的 ACK。")]),v._v(" "),t("p",[v._v("比如第 5 个包丢失了，那么第6，7个到达，接收端会一律返回第 4 个包的 ACK。当发送端收到三个重复的 ACK 时，意识到丢包了，马上进行重传，不用等到一个 RTO 的时间到了才重传。")]),v._v(" "),t("h3",{attrs:{id:"选择性重传-解决的是如何重传的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择性重传-解决的是如何重传的问题"}},[v._v("#")]),v._v(" 选择性重传 （解决的是如何重传的问题）")]),v._v(" "),t("p",[v._v("如果只是第 5 个包丢失，但是6，7个包已经被接收到了。")]),v._v(" "),t("p",[v._v("这个时候 TCP 会进行记录哪些包到达了，哪些没有到达，针对性的重传。")]),v._v(" "),t("p",[v._v("在收到发送端的报文之后，接收端回复一个 ACK 报文，就会在这个报文首部的可选项中，可以加上 SACK 这个属性，通过 left edge 和 right edge 告知发送端已经收到哪些区间的数据报。这样，就会针对性的重传第 5 个包。")]),v._v(" "),t("h3",{attrs:{id:"快速恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速恢复"}},[v._v("#")]),v._v(" 快速恢复")]),v._v(" "),t("p",[v._v("如果发送端收到三次重复 ACK 之后，发现丢包，会认为现在的网络已经有些拥塞了，就会进入快速恢复阶段。")]),v._v(" "),t("p",[v._v("发送端会作出改变：")]),v._v(" "),t("ul",[t("li",[v._v("拥塞阈值降低为 cwnd 的一半。")]),v._v(" "),t("li",[v._v("cwnd 的大小变为拥塞阈值。")]),v._v(" "),t("li",[v._v("cwnd 线性增加。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);