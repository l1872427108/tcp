(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{406:function(v,_,t){"use strict";t.r(_);var a=t(56),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"nagle算法和延迟确认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nagle算法和延迟确认"}},[v._v("#")]),v._v(" Nagle算法和延迟确认")]),v._v(" "),t("p",[v._v("如果发送端一直不停的发送，并且每次发送的包只有1个字节，那么发发送1千个字节就需要发送1千次。")]),v._v(" "),t("p",[v._v("频繁发送不仅带来传输的时延消耗，发送和确认也是需要时间的，频繁的发送会带来巨大的时延。")]),v._v(" "),t("p",[v._v("避免小包的频繁发送，就是 Nagle 算法要做的事情。")]),v._v(" "),t("ol",[t("li",[v._v("当第一次发送数据时不用等待，就算 1 个字节也要立即发送。")]),v._v(" "),t("li",[v._v("后面发送要满足以下条件：\n"),t("ul",[t("li",[v._v("数据包大小达到最大段大小。 MSS")]),v._v(" "),t("li",[v._v("之前所有包的 ACK 都已经收到。")])])])]),v._v(" "),t("h2",{attrs:{id:"延迟确认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#延迟确认"}},[v._v("#")]),v._v(" 延迟确认")]),v._v(" "),t("p",[v._v("如果发送了一个包，很短的时间又收到一个包，那么是一个个的回复，还是做一次性的回复呢？")]),v._v(" "),t("p",[v._v("延迟确认，就是将两个包合并 ACK 回复发送端，但需要稍稍的延迟。TCP 要求这个延迟的时延必须小于 500ms，一般操作系统都不会超过 200ms。")]),v._v(" "),t("p",[v._v("有些情况下，收到了就必须马上回复：")]),v._v(" "),t("ul",[t("li",[v._v("接收到了大于一个 frame 的报文，且需要调整窗口大小.")]),v._v(" "),t("li",[v._v("TCP 处于 quickack 模式。")]),v._v(" "),t("li",[v._v("发现了乱序包。")])]),v._v(" "),t("p",[v._v("如果使用延迟确认，再加上后者的延迟，将会造成更大的延迟。")])])}),[],!1,null,null,null);_.default=l.exports}}]);