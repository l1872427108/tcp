(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{408:function(t,v,_){"use strict";_.r(v);var s=_(56),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"tcp-四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[t._v("#")]),t._v(" TCP 四次挥手")]),t._v(" "),_("p",[t._v("刚开始双方都是处于连接状态的.")]),t._v(" "),_("p",[t._v("客户端要断开了，向服务器发送 FIN 报文（FIN 是finish）。")]),t._v(" "),_("p",[t._v("发送后客户端变成了 FIN-WAIT-1 状态，并且也处于一个半关闭的状态，即无法向服务端发送报文，只能接收。")]),t._v(" "),_("p",[t._v("服务端接收到 FIN 报文之后，并不会立即的用 FIN 报文去回复客户端，而是向客户端发送一个确认序号 ACK, 同时通知自己相应的应用程序，对方要求关闭连接（先发送 ACK 的目的是为了防止在这个段内，对方重传 FIN 报文段）。服务端处于 CLOSED-WAIT 状态.")]),t._v(" "),_("p",[t._v("客户端收到服务端的确认，变为 FIN-WAIT2状态。")]),t._v(" "),_("p",[t._v("服务端向客户端发送 FIN 报文，进入 LAST-ACK 状态。")]),t._v(" "),_("p",[t._v("客户端收到服务端发送来的 FIN 后，变成 TIME-WAIT 状态，然后发送 ACK 给服务端。表示连接测地被释放。")]),t._v(" "),_("p",[t._v("这个时候，客户端需要等待足够长的时间，是两个MSL（报文最大生存时间），在这个时间段内，如果客户端没有收到服务端的重发请求，表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。")]),t._v(" "),_("h1",{attrs:{id:"等待-2msl-的意义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#等待-2msl-的意义"}},[t._v("#")]),t._v(" 等待 2MSL 的意义")]),t._v(" "),_("p",[t._v("如果不等待，服务端如果还有很多数据包没有达到客户端，若客户端的端口被新的应用占用，那么就接收到了无用的数据包，造成数据包的混乱。应该等到服务器发送的数据包就没有之后在启动新的应用。")]),t._v(" "),_("p",[t._v("1个MSL 确保四次挥手中主要关闭方最后的 ACK 报文到达对端。")]),t._v(" "),_("p",[t._v("1个MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达。")]),t._v(" "),_("p",[t._v("就就是等待 2MSL 的意义。")]),t._v(" "),_("h1",{attrs:{id:"为什么是四次挥手而不是三次"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么是四次挥手而不是三次"}},[t._v("#")]),t._v(" 为什么是四次挥手而不是三次？")]),t._v(" "),_("p",[t._v("服务端在接收到 FIN, 不能够立即返回 FIN，必须等到服务端所有的报文都发送完毕，才能，才能发送 FIN. 因此要先发送一个 ACK 表示收到客户端的 FIN，迟一段时间才会发 FIN。")]),t._v(" "),_("p",[t._v("如果是三次握手，代表要将第二次和第三次进行合并，将 ACK 和 FIN 一同发送给客户端，这样如果长时间的延迟导致客户端误以为 FIN 没有达到客户端，从而让客户端不断重发 FIN。")])])}),[],!1,null,null,null);v.default=a.exports}}]);